---
title: "HW4 - DATA622"
author: "Group 1"
date: "11/3/2021"
output:
  html_document: 
    toc: true
    toc-title: "HW4 - DATA622"
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
    theme: united
    highlight: tango
  pdf_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(inspectdf)
library(psych)
library(kableExtra)
library(mice)
library(janitor)
library(e1071)
library(caret)
library(tidymodels)
```


### Group 1 Members:
-   David Moste
-   Vinayak Kamath
-   Kenan Sooklall
-   Christian Thieme
-   Lidiia Tronina

\pagebreak

## Introduction

For this project, we will be working with a mental health [dataset](https://raw.githubusercontent.com/christianthieme/Machine_Learning_Big_Data/main/HW4/ADHD_data.csv) obtained from a previously completed ADHD research project. The dataset contains information from 175 individuals who took part in the study and includes 54 columns broken into the following categories: 

| Excel Column | Variable                 | Key                                  |
|--------------|--------------------------|--------------------------------------|
| C            | Sex                      |  Male-1, Female-2                    |
| D            | Race                     |  White-1, African American-2, Hispanic-3, Asian-4, Native American-5, Other or missing data -6 |
| E-W          | ADHD self-report scale | Never-0, rarely-1, sometimes-2, often-3, very often-4 |
| X-AM         | Mood disorder questions |  No-0, yes-1; question 3: no problem-0, minor-1, moderate-2, serious-3 |
| AN-AS        | Individual substances misuse |  no use-0, use-1, abuse-2, dependence-3 |
| AT           | Court Order |  No-0, Yes-1 |
| AU           | Education | 1-12 grade, 13+ college |
| AV           | History of Violence | No-0, Yes-1 |
| AW           | Disorderly Conduct | No-0, Yes-1 |
| AX           | Suicide attempt | No-0, Yes-1 |
| AY           | Abuse History | No-0, Physical (P)-1, Sexual (S)-2, Emotional (E)-3, P&S-4, P&E-5, S&E-6, P&S&E-7 |
| AZ           | Non-substance-related Dx | 0 – none; 1 – one; 2 – More than one |
| BA           | Substance-related Dx | 0 – none; 1 – one Substance-related; 2 – two; 3 – three or more |
| BB           | Psychiatric Meds | 0 – none; 1 – one psychotropic med; 2 – more than one psychotropic med | 


Our task is first to explore the data, then using the understanding gained, to build a clustering model to determine different segments of patients. Additionally, we'll perform Principal Component Analysis on a subset of the dataset to see what information can be gleaned. Finally, we'll use Gradient Boosting and Support Vector Machines to predict if a patient will commit suicide.  

As can be seen from the table above, the dataset has a wide variety of numeric and categorical data. We'll dive deeper into this data now.

## Exploratory Data Analysis

```{r message=FALSE, warning=FALSE, include=FALSE}
adhd <- readr::read_csv('https://raw.githubusercontent.com/christianthieme/Machine_Learning_Big_Data/main/HW4/ADHD_data.csv')
```

Let’s begin exploring by taking a high level look at our dataset:

```{r}
glimpse(adhd)
```
We can see that there is a mix of both numeric and categorical data. We note that most of the numerical features are actually binary categorical variables. Before going too far, let's change the data type of these variables so we can explore our data properly: 

```{r}
adhd <- adhd %>% mutate_if(is.double, as.factor)
adhd$Age <- as.integer(adhd$Age)

inspectdf::inspect_types(adhd) %>%
  show_plot
```

Having made the necessary changes, we can see in the visual above, that our dataset is mostly categorical data. However, there is one column that is of type character and another column that is of type integer. 

## Numerical Features

```{r}
table <- describe(adhd$Age)[,c(2,8,3,5,9,4)]
rownames(table) <-  c('Age')


knitr::kable(table) %>%
  kable_styling()
```
Looking at the summary above, we can see that the age of the subjects of this research study are between 1 and 42 with the median value being 25. Let's now take a look at the shape of our distribution and see if there are significant outliers: 

```{r}
inspectdf::inspect_num(adhd) %>% 
 show_plot()
```
In looking at the distribution of age, it appears that our dataset is multi-modal. This often means that there are sub-populations within the data. We'll keep this in mind as we continue our exploration. We do not see any significant outliers. 

Later, we will be building models to attempt to predict individuals who have committed suicide. As such, we'll look at the distribution of Age broken down by whether an individual has attempted suicide or not: 


```{r message=FALSE, warning=FALSE}
ggplot(adhd %>% filter(Suicide %in% c(1,0)) ) + 
  aes( y = Age, fill = Suicide) + 
  geom_histogram() +
  coord_flip()
 
```

Based on the histogram above, we do not note any significant differences in the distributions. However, this may be more easily determined by looking at a boxplot. 

```{r}
 ggplot(adhd %>% filter(Suicide %in% c(1,0))) + 
       aes(x = Suicide, y = Age) + 
       geom_boxplot(color = 'steelblue', 
                    outlier.color = 'firebrick', 
                    outlier.alpha = 0.35) +
        labs(title = 'Suicide vs Loan_Status', y = 'Age', x= 'Suicide') +
        theme_minimal() + 
        theme(
          plot.title = element_text(hjust = 0.45),
          panel.grid.major.y =  element_line(color = "grey", 
                                             linetype = "dashed"),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.grid.minor.x = element_blank(),
          axis.ticks.x = element_line(color = "grey")
        )
       
      
```

In looking at the boxplots above, we can see that it does appear that, in general, those who attempted suicide were younger than those who did not. 

## Categorical Features 

Now let’s turn our attention to our categorical variables. We have both binary categorical variables, and variables with 3 or more classes. Looking at this data in a table would be unwieldy due to its size, so we'll visualize this data instead. 

```{r fig.height=10, fig.width=8}
inspect_cat(adhd) %>% 
  show_plot()
```

In looking at the summary table above, we note: 

* `Abuse`: Nearly half of our population has been subject to some type of abuse 
* `ADHD Q1-18`: There is a fairly equal dispersion between each of these responses
* `Alcohol`: Alcohol appears to be used by half of our population
* `Cocaine`: About a 1/3 of the population uses cocaine
* `Court Order`: Majority of the population does not have a court order
* `Disorderly Conduct`: Over half of the population has had disorderly conduct
* `Education`: A very small percentage of population has attended college
* `Hx of Violence`: Subjects with a history of violence is the minority of the population
* `MDQ1-MDQ3`: There is a fairly even breakout in response for each of these questions
* `Non-subst Dx`: We note the presence of quite a few missing values in this column. Most individuals do not have a non-substance prescription
* `Opiods`: Most subjects do not have opiods
* `Psych meds.`: The majority of this column is missing data
* `Race`: The majority of the population is either white or African American
* `Sedative-hypnotics`: Hardly anyone in the population is using sedative-hypnotics
* `Sex`: The population is a fairly even split between males and females
* `Stimulants`: Stimulant usage among the participants is very minimal
* `Subst Dx`: A fairly even split between each of these categories. We note the presence of quite a few missing values in this column.
* `Suicide`: It appears that around around a 1/4 of the population has attempted suicide
* `THC`: THC only affects around 1/3 of our population

Again, we will be building models to predict who has attempted to commit suicide, so it will also be helpful to understand the the distributions of these variables as it relates to our `Suicide` variable, both Yes and No. As mentioned above, only 1/4 of the population has attempted suicide, so we expect counts for those who have attempted suicide to be considerably lower than those who have not, however, we perform this exercise to see anything major sticks out as a red flag. 

```{r  echo=FALSE,warning=FALSE, fig.height=15, fig.width=12}
suicide_graph <- adhd %>%
    select(-Age, -Initial, -'ADHD Total', -'MD TOTAL') %>%
    gather(-Suicide, key = "var", value = "val") %>%
    ggplot(aes(x = val, fill=factor(Suicide))) +
    geom_bar(position="dodge", alpha=0.5) +
    facet_wrap(~ var, scales = "free") +
    scale_fill_manual("Suicide",values = c("#58BFFF", "#3300FF")) +
    xlab("") +
    ylab("") +
    theme(panel.background = element_blank(), legend.position="top")
suicide_graph
```

Based on the charts above, we do not note anything we would consider out of the ordinary where suicide attempts outnumber those who have not attempted suicide for any of the variables. In fact, the distributions look fairly similar given our understanding of the percentage of those who have attempted suicide. 

## Missing Data

As we've seen throughout out EDA, there are quite a few missing values within the columns. Let's take a closer look at this so we can determine the best way to deal with them. 

```{r fig.height=6, fig.width=12}
visdat::vis_miss(adhd, sort_miss = TRUE)
```

It appears that about 2.6% of our dataset is missing values and as previously mentioned, `Psych meds.` makes up a large portion of that. Because of this, there would be no good way to impute these values and so we have decided to drop this variable from the dataset. 

```{r}
adhd <- adhd %>% 
  select(-`Psych meds.` )
```


Further, we see a pattern within the missing data that many of the respondents who have missing data about a suicide attempt, also have additional missing data. As our objective is to predict suicide attempts, we will drop those subjects who have missing data for that variable since the data will be unusable when it comes to our modeling. 

```{r}
adhd <- adhd %>% 
  filter(!is.na(Suicide))
```

Having adjusted these, let's now look at our missing data again. 

```{r fig.height=6, fig.width=12}
visdat::vis_miss(adhd, sort_miss = TRUE)
```

We can see clearly that these adjustments have made a significant impact on the dataset. There is now only 0.4% of our dataset that is missing. We can now use an imputation method to fill in the remainder of the missing values. 

We have chosen to use the pmm method (predictive mean matching) from the mice library to impute our missing values. Predictive mean matching calculates the predicted value for our target variable, and, for missing values, forms a small set of “candidate donors” from the complete cases that are closest to the predicted value for our missing entry. Donors are then randomly chosen from candidates and imputed where values were once missing. To apply pmm we assume that the distribution is the same for missing cells as it is for observed data, and thus, the approach may be more limited when the % of missing values is higher. 

In order to apply this method, we'll need to adjust our column names that have spacing. We can use the `clean_names` function from the `janitor` library to do this for us. Once this is completed, we'll impute our missing values: 

```{r}
adhd <- adhd %>% 
  janitor::clean_names()

adhd <- mice(data = adhd, m = 1, method = "pmm", seed = 500)
adhd <- mice::complete(adhd, 1)
```

We can see now that we have successfully imputed all missing values: 

```{r}
visdat::vis_miss(adhd, sort_miss = TRUE)
```

## Modeling

### K-Means Clustering

K-Means clustering is a technique of creating clusters by finding groups that are similar, as determined by euclidean distance. This method has many advantages (computationally efficient) and disadvantages (results change with every run, dependent on the starting values, no real way to determine appropriate number of clusters), but we ultimately chose to use k-means instead of hierarchical clustering due to there being no real reason to believe this data has a hierarchical structure to it.

The first step was to pull out only the columns we wanted to use. Since k-means is based on euclidean distance, we chose to only use variables that had continuous values, ruling out all binary and factor based predictors. Some of this data came in as factors (despite it being continuous), so we had to convert those to numeric values.

```{r}
library(tidyverse)

adhd_km <- adhd %>%
  select(age, md_total, education, adhd_total)

adhd_km <- adhd_km %>%
  mutate_if(is.factor, as.character) %>%
  mutate_if(is.character, as.numeric)
```

The next step was to transform the data. Again, the euclidean based distance measurement calls for us to center and scale the data. We also chose to perform a Box-Cox transformation to help reduce skewness.

```{r}
library(caret)

adhd_km_trans <- preProcess(adhd_km,
                            method = c("center", "scale", "BoxCox"))
adhd_km_trans <- predict(adhd_km_trans, adhd_km)
```

Now that we have our data all set up, we could go ahead and get a sense of how many clusters to create. To do this, we used the silhouette method. When the average silhouette width starts to decrease, you stop gaining information by dividing clusters. This led us to an optimal number of 2 cluster.

```{r}
library(factoextra)

fviz_nbclust(adhd_km_trans, kmeans, method = "silhouette", k.max = 20)
```

Now we finally get to create and visualize our clusters! To visualize these four dimensional clusters, we used PCA to reduce the dimensionality of our data.

```{r}
library(factoextra)

km.res <- kmeans(adhd_km_trans, centers = 2, nstart = 50)
fviz_cluster(km.res, adhd_km_trans)
```

What incredible clusters! We wanted to get a better sense of the differences between these clusters and what made them unique, so we went back to the original data and performed a little bit of analysis. We computed the mean for each factor within each cluster and plotted these values on a graph to see the differences in the two clusters more clearly.

```{r}
library(tidyverse)

adhd_km_res <- cbind(adhd_km, km.res$cluster)

km_comparison <- adhd_km_res %>%
  group_by(km.res$cluster) %>%
  rename(cluster = `km.res$cluster`) %>%
  summarise_all(mean) %>%
  pivot_longer(c("age":"adhd_total"),
               names_to = "category",
               values_to = "mean")

ggplot(km_comparison,
       aes(x = as.factor(cluster),
           y = mean,
           fill = as.factor(category))) +
  geom_bar(position = "fill",
           stat = "identity") +
  scale_fill_brewer(palette = "Set3") +
  labs(x = "Cluster",
       y = "Value",
       fill = "Factor")
```

By looking at these two clusters, we can see that one of our clusters has a high total ADHD and MD score while also having a lower age and education. This would indicate that our two groups are the following:
*Younger and less educated with high ADHD and MD scores
*Older and more educated with lower ADHD and MD scores

Out of curiosity, we wanted to add back in a single binary variable - suicide - since we knew we would be investigating it later. We knew k-means would struggle with this, but we were curious to see how much it would impact the outcome.

We went through the same steps as before, but this time included suicide as our first variable.

```{r}
library(tidyverse)
library(caret)
library(factoextra)

adhd_km <- adhd %>%
  select(suicide, age, md_total, education, adhd_total)

adhd_km <- adhd_km %>%
  mutate_if(is.factor, as.character) %>%
  mutate_if(is.character, as.numeric)

adhd_km_trans <- preProcess(adhd_km,
                            method = c("center", "scale", "BoxCox"))
adhd_km_trans <- predict(adhd_km_trans, adhd_km)

fviz_nbclust(adhd_km_trans, kmeans, method = "silhouette", k.max = 20)

km.res <- kmeans(adhd_km_trans, centers = 12, nstart = 50)
fviz_cluster(km.res, adhd_km_trans)

adhd_km_res <- cbind(adhd_km, km.res$cluster)

km_comparison <- adhd_km_res %>%
  group_by(km.res$cluster) %>%
  rename(cluster = `km.res$cluster`) %>%
  summarise_all(mean) %>%
  pivot_longer(c("suicide":"adhd_total"),
               names_to = "category",
               values_to = "mean")

ggplot(km_comparison,
       aes(x = as.factor(cluster),
           y = mean,
           fill = as.factor(category))) +
  geom_bar(position = "fill",
           stat = "identity") +
  scale_fill_brewer(palette = "Set3") +
  labs(x = "Cluster",
       y = "Value",
       fill = "Factor")
```

Adding in just one binary variable - suicide - had a massive impact on our clustering. The optimal number of clusters increased by 600% all the way up to 12 clusters. All of a sudden we have clusters that fit a bunch of different scenarios. Based on our clusters, we ended up with the following conclusions:
* We had 4 groups that had non-zero means for suicide (meaning suicide was attempted)
* Of these 4 groups, 3 had higher ADHD scores, 1 was an older group and 1 was a younger group, and education for all 4 groups was low.

We're curious if the massive increase in the optimal number of clusters was caused by the addition of a single variable or the addition of a binary variable. The best way to tell would be to replace the binary suicide variable with another continuous variable, but we already used all of the provided continuous variables. We could always remove one of our original variables and retain the binary suicide variable, but even this would cause some level of distortion.

### Support Vector Machine

A Support Vector Machine (SVM) is an algorithm that searches the feature space for the optimal hyper plane. This hyper plane will separate the features by classes with the maximum margin. Here we train an SVM to find the dividing plane between those who commit suicide and those who don't base on the features we have.

We begin by dropped the initial column as that may not carry any predicative information. The data is then split into training and testing

```{r}
df_split = initial_split(adhd %>% select(-c(initial)), strata=suicide)
df_train <- training(df_split)
df_test <- testing(df_split)
```

The trained dataset is fit to an SVM

```{r}
set.seed(42)
svm_model = svm(suicide~., data=df_train, kernel='linear', probability=TRUE)
summary(svm_model)
```

Our base model consists of 78 support vectors where 45 are assign to label 0 (no suicide) and 33 to label 1 (suicide)

We will tune the svm with the training set to find the best gamma and cost. The tuning process is done with 10 fold cross validation.

```{r}
svm_tune <- tune.svm(suicide~., data = df_train, gamma = 0.25, cost = seq(0.1,1,0.1))
summary(svm_tune)
svm_best <- svm_tune$best.model
```

It looks like the best parameters are gamma = 0.25 and cost = 0.1

```{r, echo=F}
svm_model = svm(suicide~., data=df_train, cost=0.1, gamma=0.25, kernel='linear', probability=TRUE)
summary(svm_model)
svm_best <- svm_model
```

Now with the best model we can test it aganist the train and test set

```{r}
y_train = predict(svm_best, df_train %>% select(-c(suicide)))
table(df_train[,'suicide'], y_train)

y_test = predict(svm_best, df_test %>% select(-c(suicide)))
table(df_test[,'suicide'], y_test)
confusionMatrix(df_test[,'suicide'], y_test, positive='1')
```

As we can see the SVM model has 4 False Positive on the training set. However it makes more mistakes on the testing set, which is to be expected. 

```{r}
pred <- predict(svm_best, df_test, decision.values = TRUE, probability = TRUE)
pred_prob <- attr(pred, 'probabilities')
df_prob <- cbind(df_test %>% select(suicide), y_test, pred_prob)
names(df_prob) = c('y_true' ,'y_pred', 'negative', 'positive')
summary(df_prob)
```

We can see from the predicted probabilities the SVM model is more likely to predict that an individual will not commit suicide.


